import datetime
from typing import Any, Iterable
from django.db import models
import pandas as pd

# Create your models here.
# Product : name(pk) , company , category , base , size(text), pur_price , sale_price , opening_stock 
# hsn , rt .
# Name is auto generated by the system , which is a combination of category + base + size .
class Product(models.Model):
    name = models.CharField(max_length=100, primary_key=True, editable=False)
    company = models.CharField(max_length=100)
    category = models.CharField(max_length=100)
    base = models.CharField(max_length=100,null=True,blank=True)
    size = models.CharField(max_length=100)
    dpl = models.IntegerField(null=True,blank=True)
    mrp = models.IntegerField()
    opening_stock = models.IntegerField(default=0)
    hsn = models.CharField(max_length=100)
    rt = models.FloatField()
    
    def save(self, *args, **kwargs):
        self.category = self.category.upper()
        self.base = (self.base or "").upper()
        self.size = (self.size or "").upper()
        self.name = f"{self.category} {self.base} {self.size}"
        return super().save(*args, **kwargs)

    def __str__(self):
        return self.name
    


# Customer : name(pk) , gstin , phone , address 
class Customer(models.Model):
    name = models.CharField(max_length=100, primary_key=True)
    gstin = models.CharField(max_length=100,null=True,blank=True)
    phone = models.CharField(max_length=100)
    address = models.TextField()
    opening_balance = models.FloatField(default=0)

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)
        Outstanding.update()
        
    def __str__(self):
        return self.name
    
# Supplier : name(pk) , gstin , phone , address
class Supplier(models.Model):
    name = models.CharField(max_length=100, primary_key=True)
    gstin = models.CharField(max_length=100,null=True,blank=True)
    phone = models.CharField(max_length=100)
    address = models.TextField()

    def __str__(self):
        return self.name
    
# Sale : bill_no(pk) , date , customer , amt 
class Sale(models.Model):
    bill_no = models.CharField(max_length=15,primary_key=True)
    date = models.DateField(default=datetime.date.today)
    customer = models.ForeignKey(Customer, on_delete=models.CASCADE)
    amt = models.FloatField(null=True,verbose_name="Total Bill Value")

    @staticmethod 
    def monthly_sales_total() : 
        return round(Sale.objects.filter(date__month=datetime.date.today().month).aggregate(models.Sum('amt'))['amt__sum'] or 0)
        
    def save(self, *args, **kwargs):
        if not self.bill_no:  # Generate only if not already set
            last_bill = Sale.objects.order_by('-bill_no').first()
            if last_bill:
                last_number = int(last_bill.bill_no[1:])  # Extract number part
                new_number = f"S{last_number + 1:05d}"  # Increment and format
            else:
                new_number = "S00001"  # First bill case
            self.bill_no = new_number
        super().save(*args, **kwargs)
        Outstanding.update()
     
    def delete(self,*args, **kwargs):
        super().delete(*args, **kwargs)
        Outstanding.update()

    def __str__(self):
        return str(self.bill_no)
    
# SaleProduct : sale , product , qty , price
class SaleProduct(models.Model):
    sale = models.ForeignKey(Sale, on_delete=models.CASCADE,related_name="products")
    product = models.ForeignKey(Product, on_delete=models.DO_NOTHING,related_name="sales")
    qty = models.IntegerField()
    price = models.FloatField(verbose_name="Sale Price / Unit")
    
    

    def __str__(self):
        return f"{self.sale} - {self.product}"
    
# Purchase : bill_no(pk) , date , supplier , amt
class Purchase(models.Model):
    bill_no = models.CharField(max_length=15,primary_key=True)
    date = models.DateField(default=datetime.date.today)
    supplier = models.ForeignKey(Supplier, on_delete=models.CASCADE)
    amt = models.FloatField(null=True,verbose_name="Total Bill Value")

    @staticmethod
    def monthly_purchase_total() :
        return round(Purchase.objects.filter(date__month=datetime.date.today().month).aggregate(models.Sum('amt'))['amt__sum'] or 0)
    
    def __str__(self):
        return str(self.bill_no)
    
# PurchaseProduct : purchase , product , qty , price
class PurchaseProduct(models.Model):
    purchase = models.ForeignKey(Purchase, on_delete=models.CASCADE,related_name="products")
    product = models.ForeignKey(Product, on_delete=models.DO_NOTHING,related_name="purchase")
    qty = models.IntegerField()
    base_rate = models.FloatField(verbose_name="Base Rate / Unit")
    discount = models.FloatField(verbose_name="Total Discount")
    price = models.FloatField(verbose_name="Purchase Price / Unit")
    
    def save(self, *args, **kwargs):
        self.price = self.base_rate - (self.discount/self.qty) 
        return super().save(*args, **kwargs)
    
    def __str__(self):
        return f"{self.purchase} - {self.product}"





# Collection : date , amt , customer , mode , bill_no
class Collection(models.Model):
    date = models.DateField(verbose_name="Collection Date",default=datetime.date.today)
    customer = models.ForeignKey(Customer, on_delete=models.DO_NOTHING)
    mode = models.CharField(max_length=100,choices=[("Cash","Cash"),("Cheque","Cheque"),("UPI","UPI")])
    amt = models.FloatField(verbose_name="Total Collection")

    @staticmethod 
    def monthly_coll_total() : 
        return round(Collection.objects.filter(date__month=datetime.date.today().month).aggregate(models.Sum('amt'))['amt__sum'] or 0)
       
    def __str__(self):
        return f"{self.date} - {self.customer} - {self.amt}"
    
    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)
        Outstanding.update()

    def delete(self,*args, **kwargs):
        super().delete(*args, **kwargs)
        Outstanding.update()

# CollectionEntry : bill_no , date
class CollectionBillEntry(models.Model):    
    collection = models.ForeignKey("app.Collection", on_delete=models.CASCADE)
    bill = models.ForeignKey(Sale, on_delete=models.DO_NOTHING,verbose_name="Sales Bill No")
    amt = models.FloatField(verbose_name="Amount Collected")
    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)
        Outstanding.update()

class Outstanding(models.Model) : 
      customer = models.CharField(max_length=100)
      bill_no = models.CharField(max_length=20,primary_key=True)
      balance = models.FloatField()
      date = models.DateField()
      
      def __str__(self):
          return f"{self.bill_no}"
      
      @staticmethod 
      def total() : 
            return round(abs(Outstanding.objects.aggregate(models.Sum('balance'))['balance__sum'] or 0))
      
      @staticmethod               
      def update() :
        from django.db import connection
        with connection.cursor() as cursor:
            cursor.execute( 'DELETE FROM app_outstanding' )
            cursor.execute('''
                INSERT INTO app_outstanding (customer, bill_no, balance, date)
                SELECT customer_id as customer   , bill_no, SUM(amt) AS balance, MIN(date) AS date 
                FROM (
                SELECT customer_id , bill_no , date, -amt as amt  FROM app_sale
                UNION ALL
                SELECT customer_id, bill_id as bill_no , date, amt FROM (select app_collectionbillentry.amt as amt , * from app_collection join app_collectionbillentry on app_collection.id = app_collectionbillentry.collection_id)
                ) 
                GROUP BY customer_id , bill_no 
                HAVING ABS(SUM(amt)) > 1 
                
            ''')
      
      class Meta : 
            verbose_name_plural = 'Outstanding'
            ordering = ['bill_no']
